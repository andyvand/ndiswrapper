#!/usr/bin/perl -d

#/*
#*  Copyright (C) 2005-2006 Pontus Fuchs, Giridhar Pemmasani
#*
#*
#*  This program is free software; you can redistribute it and/or modify
#*  it under the terms of the GNU General Public License as published by
#*  the Free Software Foundation; either version 2 of the License, or
#*  (at your option) any later version.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#*  GNU General Public License for more details.
#*
#*/


use strict;
use Fcntl ':mode';
use File::Basename;
use File::Copy;
use File::Listing;
use File::Path;

my $WRAP_PCI_BUS = 5;
my $WRAP_PCMCIA_BUS = 8;
my $WRAP_USB_BUS = 15;

my %sections;
my %parsed_sections;
my $confdir = "/tmp/ndiswrapper";
my $src_dir;
my $driver_name;

#Blacklist of files not to install.
my @copy_blacklist;

#Fixup list for parameters.
my %param_fixlist = ("EnableRadio|0" => "1",
		     "IBSSGMode|0" => "2",
                     "PrivacyMode|0" => "2",
		     "AdhocGMode|1" => "0");

if(@ARGV < 1) {
	usage();
	exit();
}

my $modconf;
if (`uname -r` =~ /(\d+)\.(\d+)\.(\d+)/) {
    if ($2 > 4) {
	if (-d "/etc/modprobe.d") {
	    $modconf = "/etc/modprobe.d/ndiswrapper" 
	} else {
	    $modconf = "/etc/modprobe.conf" 
	}
    } else {
	if (-d "/etc/modutils") {
	    $modconf = "/etc/modutils/ndiswrapper";
	} else {
	    $modconf = "/etc/modules.conf";
	}
    }
}

my $res;
my $dbg_file;

$dbg_file = ">/dev/null";
$dbg_file = ">/tmp/ndiswrapper.dbg";

open(DBG, $dbg_file) or die "couldn't open $dbg_file: $!";

if($ARGV[0] eq "-i" and @ARGV == 2) {
    $res = install($ARGV[1]);
} elsif($ARGV[0] eq "-v" and @ARGV == 1) {
    printf "utils "; system("/sbin/loadndisdriver -v");
    printf "driver ";
    system("modinfo ndiswrapper | grep -E '^version|^vermagic'");
    $res = 0;
} else {
    usage();
}
close(DBG);
exit $res;

sub usage {
    print "Usage: ndiswrapper OPTION\n\n" .
      "Manage ndis drivers for ndiswrapper.\n"  .
	"-i inffile        Install driver described by 'inffile'\n" .
	"-v                Report version information\n" .
	"\n\nwhere 'devid' is either PCIID or USBID of the form XXXX:XXXX\n";
}

sub install {
    my $inf = shift;
    $src_dir = dirname($inf);
    $driver_name = lc(basename($inf));
    $driver_name =~ s/\.inf//;
    chomp($driver_name);

    if (! -d $confdir) {
	mkdir($confdir) or die "couldn't create $confdir: $!";
    }
    if (! -d $confdir . "/" . $driver_name) {
	mkdir($confdir . "/" . $driver_name) or
	  die "couldn't create $confdir/$driver_name: $!";
    }
    print "installing $driver_name ...\n";
    read_sections($inf);
    parse_section("Strings");
    parse_section("Version");
    parse_mfr();
    copy_file(basename($inf));
    return 0;
}

# Loacate a section.
sub get_section {
    my $name = shift;
    foreach my $key (keys %sections) {
	if (lc($key) eq lc($name)) {
	    return @{$sections{$key}};
	}
    }
    return ();
}

#
# Load inf and split into different sections.
#
sub read_sections {
    my $filename = shift;
    open(INF, $filename) or die "couldn't open $filename: $!";

    my $name = "none";
    my $i = 0;
    $sections{$name} = ();
    while (my $line = <INF>) {
	#Convert from unicode
	$line =~ s/\xff\xfe//;
	$line =~ s/\0//g;

	$line =~ s/^\s*//;
	$line =~ s/\s*$//;
	next if length $line == 0;
	if ($line =~ /^\[(.+)\]/) {
	    $name = $1;
	    $sections{$name} = ();
	    $i = 0;
	} else {
	    $sections{$name}[$i++] = $line;
	}
    }
    close(INF);
    foreach $name (keys %sections) {
	printf DBG "section: %s\n", $name;
	foreach my $line (@{$sections{$name}}) {
	    printf DBG "%s: %s\n", $name, $line;
	}
    }
}

sub parse_section {
    my $name = shift;
    my @lines = get_section($name);
    if (!@lines) {
	return;
    }
    $parsed_sections{$name} = {};
    foreach my $line (@lines) {
	(my $key, my $val) = parse_key_value($line);
	if ($key) {
	    $val = strip_quotes($val);
	    $parsed_sections{$name}->{$key} = $val;
	    printf DBG "$name: %s = %s\n", $key, $val;
	}
    }
}

sub parse_mfr() {
    my @lines = get_section("Manufacturer");
    foreach  my $line (@lines) {
	(my $strkey, my $val) = parse_key_value($line);
	if ($strkey) {
	    (my $models, my @targets) = split(",", $val);
	    if ($models) {
		my $target_os = find_target_os(@targets);
		parse_models($models, $target_os);
	    }
	}
    }
}

sub parse_models {
    my $models = shift;
    my $os = shift;
    my @lines = get_section($models . "." . $os);
    if (@lines eq 0) {
	@lines = get_section($models);
	if (@lines eq 0) {
	    return;
	}
    }
    foreach my $line (@lines) {
	(my $dev_desc, my $val) = parse_key_value($line);
	my @fields = split(",", $val);
	my $install_section = $fields[0];
	my $hwid = $fields[1];
	# TODO: deal with compatible IDs as hwid?
	(my $bus_type, my $vendor, my $device, my $subvendor, my $subdevice) =
	  parse_hwid($hwid);
	next if (!$vendor);
	parse_install($bus_type, $install_section, $os, $vendor, $device,
		      $subvendor, $subdevice);
    }
}

sub parse_install {
    (my $bus_type, my $secn, my $os, my $vendor, my $device, my $subvendor,
     my $subdevice) = @_;
    my @lines = get_section($secn . $os);
    if (@lines eq 0) {
	@lines = get_section($secn);
	if (@lines eq 0) {
	    return;
	}
    }

    my @copy_files = ();
    my $addreg;
    foreach my $line (@lines) {
	$line =~ s/^;\s*//;
	$line = trim(del_comment($line));
	(my $key, my $val) = parse_key_value($line);
	if ($key) {
	    if (lc($key) eq "addreg") {
		$addreg = $val;
	    } elsif (lc($key) eq "copyfiles") {
		push @copy_files, $val;
	    }
	}
    }

    my $filename = "$vendor:$device";
    if ($subvendor) {
	$filename .= ":$subvendor:$subdevice"
    }

    my $bus = sprintf("%X", $bus_type);
    $filename .= ".$bus.conf";

    open(CONF, ">$confdir/$driver_name/$filename") or
      die "unable to create file $filename: $!";

    my $version = get_section_value("Version", "DriverVer");
    my $provider = get_section_value("Version", "Provider");
    my $classguid = get_section_value("Version", "ClassGUID");
    my $providerstring = trim(strip_quotes(get_string_value(trim($provider))));

    printf CONF "NdisVersion|0x50001\n";
    printf CONF "Environment|1\n";
    printf CONF "class_guid|%s\n", $classguid;
    printf CONF "mac_address|XX:XX:XX:XX:XX:XX\n";
    printf CONF "driver_version|%s,%s\n", $providerstring, $version;
    printf CONF "\n";
    close(CONF);

    open(CONF, "|sort|uniq >>$confdir/$driver_name/$filename") or
      die "couldn't create file $filename: $!";

    my @addregs = split(",", $addreg);
    foreach my $reg (@addregs) {
	parse_registry(trim($reg));
    }
    close(CONF);
    foreach my $copy_file (@copy_files) {
	my @copy_sec = split(",", $copy_file);
	foreach my $file (@copy_sec) {
	    parse_copy_files(trim($file));
	}
    }
}

sub get_section_value {
    (my $secn, my $name) = @_;
    return $parsed_sections{$secn}->{$name};
}

sub get_string_value {
    my $key = shift;
    if ($key =~ /%(.+)%/) {
	$key = $1;
	return get_section_value("Strings", $key);
    } else {
	return $key;
    }
}

sub parse_registry {
    my $reg = shift;
    my $conf = shift;
    my @lines = get_section($reg);
    if (@lines eq 0) {
	printf "parse error in inf; unable to find section $reg\n";
	return -1;
    }

    foreach my $line (@lines) {
	$line = del_comment($line);
	my @fields = split(",", $line);
	next if (@fields lt 4);
	my $value;
	my $param = trim($fields[1]);
	if ($param =~ /ndi\\params\\(.+)/i) {
	    $param = $1;
	    $param =~ s/\\.*$//;
	    next if (lc(trim($fields[2])) ne "default");
	    $value = strip_quotes(trim($fields[4]));
	} else {
	    $param = trim($fields[2]);
	    next if (length($param) eq 0);
	    $value = strip_quotes(trim($fields[4]));
	}
	$value = get_string_value($value);
	if (length($param) gt 0 and $param ne "BusType") {
	    if ($param_fixlist{"$param|$value"}) {
		my $orig_value = $value;
		$value = $param_fixlist{"$param|$value"};
		print "Forcing parameter $param from $orig_value to $value\n";
	    }
	    printf CONF "%s|%s\n", $param, $value;
	}
    }
}

sub parse_copy_files {
    my $copy_name = shift;

    if ($copy_name =~ /^\@/) {
	$copy_name =~ s/^\@//;
	return copy_file($copy_name);
    }

    my @lines = get_section($copy_name);
    foreach my $line (@lines) {
	$line = trim($line);

	my @files = split(",", $line);
	my $file;
	if (@files > 1) {
	    $file = $files[1];
	} else {
	    $file = $files[0];
	}
	$file = trim($file);
	if ($file and length($file) > 0) {
	    copy_file($file);
	}
    }
    return 0;
}

sub copy_file {
    my $file = shift;

    $file =~ s/\s*;//;
    $file = trim(del_comment($file));
    my $real_file = get_file($file);
    if (length($real_file) gt 0) {
	$file = lc($real_file);
	copy("$src_dir/$real_file", "$confdir/$driver_name/$file") or
	  warn "couldn't copy $real_file: $!";
	chmod(0644, "$confdir/$driver_name/$file");
    }
}

# Find a file in a case-insensitive way.
sub get_file {
    my $file = shift;
    if (opendir(DIR, "$src_dir")) {
	my @allfiles = readdir(DIR);
	foreach my $real_file (@allfiles) {
	    if (lc($real_file) eq lc($file)) {
		closedir(DIR);
		return $real_file;
	    }
	}
    } else {
	print "unable to open $src_dir\n";
    }
    closedir(DIR);	
    return "";
}

sub parse_hwid {
    my $hwid = uc(shift);
    if ($hwid =~ /PCI\\VEN_(\w+)&DEV_(\w+)&SUBSYS_(\w{4})(\S{4})/) {
	return ($WRAP_PCI_BUS, $1, $2, $4, $3);
    } elsif ($hwid =~ /PCI\\VEN_(\w+)&DEV_(\w+)/) {
	return ($WRAP_PCI_BUS, $1, $2);
    } elsif ($hwid =~ /USB\\VID_(\w+)&PID_(\w+)/) {
	return ($WRAP_USB_BUS, $1, $2);
    } else {
	return 0;
    }
}

sub find_target_os() {
    my @targets = @_;
    my $arch = `uname -m`;
    my $target;
    if ($arch eq "x86_64") {
	$target = "NTamd64";
    } else {
	$target = "NTx86";
    }
    foreach my $os (@targets) {
	$os =~ /([^.]+)\.([^.]+)\.(.+)/;
	if (lc($1) eq lc($target)) {
	    return $os;
	}
    }
    return "";
}

sub strip_quotes {
    my $s = shift;
    $s =~ s/"(.*)"/$1/;
    return $s;
}

sub parse_key_value {
    my $line = shift;

    $line = del_comment($line);
    if ($line =~ /([^=]+)=(.+)/) {
	return (trim($1), trim($2));
    } else {
	return 0;
    }
}

sub del_comment {
    my $s = shift;
    $s =~ s/;.*//;
    return $s;
}

# remove whitsepace at front and end.
sub trim {
    my $s = shift;
    $s =~ s/^\s*//;
    $s =~ s/\s*$//;
    return $s;
}

## Local Variables: ##
## cperl-indent-level: 4 ##
## End: ##
